(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{353:function(n,a,t){"use strict";t.r(a);var s=t(33),e=Object(s.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"一、js的单线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、js的单线程模型"}},[n._v("#")]),n._v(" 一、js的单线程模型")]),n._v(" "),t("p",[n._v("js同一时间只能在一个线程（主线程）执行，并不是说js引擎只有一个线程。\njs采用单线程有其历史原因，因为不想做的太复杂。\n多线程涉及到资源共享、可能对一个对象同时操作导致冲突，加锁机制等等。")]),n._v(" "),t("p",[n._v("好处是实现简单，问题是如果一个任务耗时过长，后面的任务排队等着，造成严重的延时，比如浏览器无响应。\njs本身并不慢，慢的是IO，网络，比如读写外部文件，网络请求和响应。")]),n._v(" "),t("p",[n._v("如果运算量大，CPU正忙也就算了，但大部分时间，CPU处于空闲状态。\njs语言的设计者意识到，可以把耗时的IO任务先挂起，先执行后面的简单任务，\n等IO任务执行完成返回结果，再把挂起的任务继续。\n这种机制就是“事件循环” Event Loop")]),n._v(" "),t("p",[n._v("现在的CPU大多数都是多核的，那如何利用多核能力呢？\nHTML5提出Web Worker标准，允许js创建多个线程，但子线程完全受主线程控制，且不能操作DOM。")]),n._v(" "),t("p",[t("strong",[n._v("那如何知道哪些任务需要挂起，哪些可以顺序执行呢？")]),n._v("\n程序里任务分为：同步任务和异步任务\n同步任务是在主线顺序执行的任务，后面的任务必须等前面的执行完才轮到，\n异步任务是先挂起，不进入主线程，而进入任务队列的任务。\n排在异步任务后面的代码不必等待其结束就可以执行，异步任务具有“不阻塞”的效应。")]),n._v(" "),t("p",[t("strong",[n._v("实际上，根据异步任务的类型，队列有多个。")])]),n._v(" "),t("p",[t("strong",[n._v("执行顺序")]),n._v("\n同步任务 -> 任务队列（有符合的任务就通过函数调用进入主线程执行，进入主线程后就变成同步任务了）")]),n._v(" "),t("p",[n._v("异步任务的写法通常是回调函数。一旦异步任务进入主线程，就会执行对应的回调函数。\n如果没有回调函数，就不会进入任务队列。")]),n._v(" "),t("p",[t("strong",[n._v("js引擎怎么知道异步任务有没有结果，能不能进入主线程？")]),n._v("\n答案是引擎会不停的检查，看同步任务是否全部执行完，\n然后去检查那些挂起的异步任务，是不是可以执行。\n这种循环检查的机制就是事件循环。\n维基百科的定义：事件循环是一个程序结构，用于等待和发送消息和事件。")]),n._v(" "),t("h2",{attrs:{id:"异步操作的模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的模式"}},[n._v("#")]),n._v(" 异步操作的模式")]),n._v(" "),t("h3",{attrs:{id:"回调函数，"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数，"}},[n._v("#")]),n._v(" 回调函数，")]),n._v(" "),t("p",[n._v("好处：简单，容易理解和实现\n缺点：不利于代码阅读和维护，各个部分高度耦合（coupling）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function f1(){\n}\nfunction f2(){\n}\nf1()\nf2()\n// 本意是先执行f1，再执行f2。\n// 如果f1是异步操作，f2会立即执行\n// 可以改成回调函数的形式\n\nfunction f1(callback){\n  ...\n  callback();\n}\nfunction f2() {\n}\nf1(f2)\n")])])]),t("h3",{attrs:{id:"事件监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[n._v("#")]),n._v(" 事件监听")]),n._v(" "),t("p",[n._v("这种思路是事件驱动模式，异步任务的执行不取决于代码的顺序，而是取决于\n某个事件是否发生。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("f1.on('done', f2)\n")])])]),t("p",[n._v("上面代码表示，当f1发生done事件，就执行f2。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function f1() {\n  setTimeout(function() {\n    f1.trigger('done');\n  },0)\n}\n")])])]),t("p",[n._v("好处：去耦合，有利于实现模块化\n缺点：流程不清晰，不利于阅读")]),n._v(" "),t("h3",{attrs:{id:"发布-订阅模式（又称观察者模式）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式（又称观察者模式）"}},[n._v("#")]),n._v(" 发布/订阅模式（又称观察者模式）")]),n._v(" "),t("p",[n._v("事件可以看作“信号”，如果存在一个信号中心，某个任务执行完成，就向信号中心发布一个信号，\n其他任务可以向信号中心“订阅”这个信号，从而知道什么时候可以执行。")]),n._v(" "),t("p",[n._v("这个模式有多种实现，比如")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// f2向信号中心$订阅done信号\n$.subscribe('done', f2);\n\n// f1执行完，向信号中心发布done信号，从而引发f2的执行。\nfunction f1() {\n  // ...\n  setTimeout(function() {\n    $.publish('done');\n  }, 1000)\n}\n\n// f2执行完，可以取消订阅\n$.unsubscribe('done', f2);\n")])])]),t("p",[n._v("这种模式可以和事件监听类似，但后者是分散的，不利于管理和维护。\n而前者是有一个中心，可以集中管理，便于控制程序的运行。")]),n._v(" "),t("h2",{attrs:{id:"异步操作的流程控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步操作的流程控制"}},[n._v("#")]),n._v(" 异步操作的流程控制")]),n._v(" "),t("p",[n._v("回调嵌套")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function async(arg, callback) {\n  console.log(arg);\n  setTimeout(function() {\n    callback()\n  },1000)\n}\n\nfunction final() {\n  \n}\n\nasync(1, function() {\n  async(2, function() {\n    async(3, function() {\n      async(4, final);\n    })\n  })\n})\n")])])]),t("p",[n._v("串行：类似把异步同步化")]),n._v(" "),t("p",[n._v("并行：同时执行，时间短，运算密集")]),n._v(" "),t("p",[n._v("串行并行结合：控制并行的数量，分组串行")]),n._v(" "),t("hr"),n._v(" "),t("h1",{attrs:{id:"定时器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[n._v("#")]),n._v(" 定时器")])])}),[],!1,null,null,null);a.default=e.exports}}]);